---
l1idx: 1
l2idx: 3
l3idx: 2
l4idx: 6
title: "In Summary"
permalink: 1_3_2_6.html
summary: "There ain't no such thing as a free lunch."
---

##  The problem, again.

The "problem" is that we want to enforce (pseudo-)symmetric routing in our network, while maintaining resiliency and load-sharing across multiple links and state-enforcing hops.  To guarantee that the same path is selected in "both directions", the path-selection mechanism *has* to act on information about both the destination *and* the source.  That's because the source and destination are *inverted* in the bi-directional flows between two endpoints.  The proverbial kick in the head is that IP routing makes forwarding decisions based on *destination* addresses only (unless we utilize policy routing.)  Generally speaking, we don't *want* to use policy routing if we don't *need* to, because it requires *per-packet* inspection of whatever fields we're basing our policy on.  

> With the relatively tightly-prescribed topology that we have defined, we know that there are two properties ("zone" and "locale") that we want to influence the path-selection.  We also know that there will be up to three equi-distant paths between endpoints with non-matching zone and locale values.  **How can we differentiate and select from those multiple equidistant paths in a manner that is bi-directionally *consistent***

## The solution (in theory)

What we "care" about is that both members of a bi-directional flow-pair between two nodes, traverse the same state-enforcing nodes.  One thing that *does* differentiate our  equi-distant paths is what "locales" the state-enforcing hops are in.  Our architecture dictates that all inter-zone/inter-locale flows will traverse *two* state-enforcing hops (one each in the same 'zone' as the endpoints).   One of the three potential equi-distant paths has two state-enforcing nodes in the same *locale* as node-A, one has two state-enforcing nodes in the same locale as node-B, and one has a single state-enforcing node in each endpoint's locale.

### Bidirectional consistency in path ***identification***

We can describe the three potential equidistant paths as:
 - The one with more state-enforcing nodes in node-A's locale
 - The one with more state-enforcing nodes in node-B's locale
 - The one with an equal number of state-enforcing nodes in both node-A and node-B's locale

That description *is* bi-directionally consistent, but requires that each forwarding/transport node know (and agree on) node-A's locale and node-B's locale, as well as the number of state-enforcing nodes in each.

The first problem is agreeing on what "node-A" and "node-B" are.  In one flow, node-A is the *source*, in the other flow, it's the *destination*.  Instead of describing the paths in terms of *node-A* and *node-B*'s locale, we could instead describe them in terms of "the *higher* or *lower* of node A/B's locale-values.  If node-A has a locale value of "10" and node-B has a locale value of "20", we would end up evaluating "the higher of *10 and 20*" in one direction, and "the higher of *20 and 10*" in the other direction.  (In both cases, it resolves to "20.")  That brings us to:
> We'll describe/differentiate our paths as:
> - The one with more state-enforcing nodes in the 'higher' endpoint's locale
> - The one with more state-enforcing nodes in the 'lower' endpoint's locale
> - The one with an equal number of state-enforcing nodes in both endpoints' locales

We could also base our evaluation on a comparison of node A/B's *zone*-values, instead of *locale*-values.  The would result in descriptions like: "the path with more state-enforcing hops in the locale of the locale of the node with the higher or lower of node A/B's zone-values" as our comparison.

### Bidirectional consistency in path ***selection***

Now that we can identify each of the potential equal-cost paths in a bidirectionally-consistent manner, we need to figure out how to decide *which* of those paths we want to use for any given bidirectional flow-pair.  We want this decision process to:
- Be bi-directionally consistent
- To load-share (at the endpoint-pair level) across all of the equal-cost paths
- To provide resiliency in the event of failure on any of the three paths

To do this, we need an evaluation function that provides the same results when its two input parameters are reversed and provides a (near) uniform distribution across three output values.  

Although it's tempting, we can't just XOR the IP-addresses (or zone-values, or locale-values) of the endpoints and perform a modulo-3 division on the result.  That *would* work well for consistency and load-sharing, but would *not* work well for resiliency (we'd need to change our modulo arithmetic every time one of the equal-cost paths showed up).  Also, it would require policy-based routing, which we very-much want to avoid.

To avoid policy-based routing, we will try to use a model that *achieves the desired results exlusively by modifying which routes are preferred by BGP* (and eschewing per-packet inspection of source-address or other fields.)

We use our observations about the distribution of zone and locale values across the graph in our prescribed topology to safely let every forwarding/transport node use it's *own* locale-value as a *proxy* for the source-node's locale-value.  This is a viable approach *only* so long as the individual forwarding/transport nodes *that have to select from among the equal-cost paths* have *the same* locale-value as the source/transmitting node of the packet that they are forwarding.  The path selection logic that solves our problem is as follows.
> - When multiple equal-cost paths are present, and the destination-address has a different *zone*-value *and* a different *locale*-value than the currently-forwarding-node
>   - If the zone-value of the destination is *higher* than "my" zone-value, prefer the path with the *most* state-enforcing hops whose site-value matches *my* site-value
>   - If the zone-value of the destination is *lower* than "my" zone-value, prefer the path with the *most* state-enforcing hops whose site-value matches  *the destination's* site-value



With our reference network topology, if node-A has a zone-value of 0.1.1, and a locale-value of 0.1.2, while node-B has a zone-value of 0.1.4, and a locale-value of 0.1.3, we get the following results:
  - All forwarding nodes with locale-value of 0.1.2 have a preferred (shortest path) route to node-A
  - All forwarding nodes with locale-value of 0.1.3 have a preferred (shortest path) route to node-B (which also has a zone v)
  - 
